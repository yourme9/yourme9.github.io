(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{415:function(e,a,s){"use strict";s.r(a);var t=s(0),n=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"map-键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-键"}},[e._v("#")]),e._v(" map----键")]),e._v(" "),a("p",[e._v("可以使用new关键字创建")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("const m = new Map()\n")])])]),a("p",[e._v("使用set方法添加key与value")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("m.set('name','Oneword')\n")])])]),a("p",[e._v("使用size查看元素个数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("console.log(m.size)   //1\n")])])]),a("p",[e._v("使用has方法进行查询 返回一个布尔值")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("console.log(m.has('name'))   //true\n")])])]),a("p",[e._v("使用delete删除某一值")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("m.delete('name')\n")])])]),a("p",[e._v("使用clear清空所有键值")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("m.clear()\n")])])]),a("p",[e._v("可使用迭代器")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("通过entries()方法 或者Symbol.iterator属性\nlet a of m.entries()   //获取到的是key与value形式的数组\n通过keys()和 values()分别返回以插入顺序生成键和值的迭代器\n")])])]),a("h2",{attrs:{id:"set-集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-集合"}},[e._v("#")]),e._v(" set----集合")]),e._v(" "),a("p",[e._v("set同样使用new关键字创建")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("const s = new Set()\n")])])]),a("p",[e._v("使用add添加元素")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("s.add('Onewoed')  \n")])])]),a("p",[e._v("同样拥有size,has,delete,clear方法但是没有set方法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("s.set('name')   //报错\n")])])]),a("p",[e._v("可使用迭代器")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("可以通过 values()方法 或者Symbol.iterator属性\nlet a of s[Symbol.iterator]  //获取以插入顺序生成集合内容\n")])])]),a("p",[e._v("可使用扩展运算符...(三个点)将集合转化成数组")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("const s = new Set(['1','2','3']);\nconsole.log([...s]);   // ['1','2','3'] \n")])])]),a("p",[e._v("set中是没有重复值得，所以可以用于数组去重")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("let arrs= [1,1,3,5,7,7,9]\nlet s = [...new Set(arrs)]\nconsole.log(s)\n")])])]),a("h2",{attrs:{id:"补充-选择map还是object-摘自于《javascript高级程序设计》第四版"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充-选择map还是object-摘自于《javascript高级程序设计》第四版"}},[e._v("#")]),e._v(" 补充：选择map还是object(摘自于《javascript高级程序设计》第四版)")]),e._v(" "),a("p",[e._v("对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("内存占用")]),a("br"),e._v("\nObject 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量\n都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。\n不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对。")]),e._v(" "),a("li",[a("strong",[e._v("插入性能")]),a("br"),e._v("\n向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快\n一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操\n作，那么显然 Map 的性能更佳。")]),e._v(" "),a("li",[a("strong",[e._v("查找速度")]),a("br"),e._v("\n与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，\n则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏\n览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言，\n查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选\n择 Object 更好一些。")]),e._v(" "),a("li",[a("strong",[e._v("删除性能")]),a("br"),e._v("\n使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，\n出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一\n种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。\n如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);